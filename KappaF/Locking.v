Require Import MetaProp.
Require Import SyntaxProp.
Require Import DynamicProp.
Require Import TypesProp.
Require Import WellFormednessProp.
Require Import Shared.

Hint Constructors is_econtext.
Hint Constructors disjointLocks.

Ltac name_step :=
  let Hstep := fresh "Hstep" in
  match goal with
    | H: step _ _ _ |- _ => rename H into Hstep
    | _ : _ |- _ => idtac
  end.

Ltac inv_step :=
  match goal with
    | H: step _ _ _ |- _ => inv H; name_step
    | _ : _ |- _ => idtac
  end.

Ltac trivial_step_case := abstract(inv_step; try(malformed_context); eauto).

Lemma stepCannotSteal :
  forall P H H' V V' n n' T1 T1' T2,
    wfLocking H T1 ->
    wfLocking H T2 ->
    disjointLocks T1 T2 ->
    P / (H, V, n, T1) ==> (H', V', n', T1') ->
    disjointLocks T1' T2.
Proof with eauto.
  introv wfL1 wfL2 Hdisj Hstep.
  gen T1'.
  induction T1; intros.
  + inv Hstep.
  + gen T1'. 
    inverts Hdisj as Hdisj1 Hdisj2.
    expr_cases (induction e) Case; intros; simpls;
    try(trivial_step_case).
    - Case "ECall". 
      apply wfLocking_econtext in wfL1... 
      inv_step; try(malformed_context); try(inv_eq)...
      * econstructor; simpl.
        introv HIn.
        apply in_app_or in HIn as []... 
        introv HIn. apply not_in_app...
      * apply IHe in Hstep as []...
    - Case "EUpdate". 
      apply wfLocking_econtext in wfL1... 
      inv_step; try(malformed_context); try(inv_eq)...
      * econstructor; simpl.
        introv HIn.
        apply in_app_or in HIn as []... 
        introv HIn. apply not_in_app...
      * apply IHe in Hstep as []...
    - Case "ELet". 
      apply wfLocking_econtext with (ctx := ctx_let s f e2) in wfL1... 
      inv_step; try(malformed_context); try(inv_eq)...
      * econstructor; simpl.
        introv HIn.
        apply in_app_or in HIn as []... 
        introv HIn. apply not_in_app...
      * apply IHe1 in Hstep as []...
    - Case "ECast". 
     apply wfLocking_econtext in wfL1... 
      inv_step; try(malformed_context); try(inv_eq)...
      * econstructor; simpl.
        introv HIn.
        apply in_app_or in HIn as []... 
        introv HIn. apply not_in_app...
      * apply IHe in Hstep as []...
    - Case "EPar". 
      inv_step; try(malformed_context)...
      econstructor; simpl...
      * introv HIn. apply in_app_or in HIn as []... 
      * introv HIn. apply not_in_app... 
    - Case "EWlock". 
      inv_step; try(malformed_context)...
      constructor. 
      * introv HIn. simpls. inv HIn...
        intros contra.
        eapply wfHeldLocks_taken in contra...
        rewrite_and_invert.
        apply wfLocking_wfHeldLocks...
      * introv HIn. intros contra.
        {inv contra.
         + eapply wfHeldLocks_taken in HIn...
           rewrite_and_invert.
           apply wfLocking_wfHeldLocks...
         + apply Hdisj1 in HIn...
        }
    - Case "EWlocked". 
      apply wfLocking_econtext in wfL1... 
      inv_step; try(malformed_context); try(inv_eq)...
      * econstructor; simpl.
        introv HIn.
        apply in_app_or in HIn as []...
        introv HIn. apply not_in_app...
      * apply IHe in Hstep as []...
      * {constructor; simpl.
         + introv HIn. apply remove_in in HIn...
         + introv HIn. apply remove_not_in...
        }
    - Case "ERlocked". 
      apply wfLocking_econtext in wfL1... 
      inv_step; try(malformed_context); try(inv_eq)...
      * econstructor; simpl.
        introv HIn.
        apply in_app_or in HIn as []...
        introv HIn. apply not_in_app...
      * apply IHe in Hstep as []...
  + apply disjointLocks_async in Hdisj as (Hdisj1 & Hdisj2 & Hdisj3). 
    inv wfL1. inv Hdisj1. inv_step; 
      try(apply disjointLocks_async);
      try(apply disjointLocks_leftmost)...
Qed.

Hint Constructors wfLocking.

Lemma wfLocking_async_preservation :
  forall P Gamma H H' V V' n n' T1 T1' T2 t,
    wfConfiguration P Gamma (H, V, n, T1) t ->
    wfLocking H T2 ->
    disjointLocks T1 T2 ->
      (forall l r,
         In (l, r) (t_rlocks T1 ++ t_rlocks T2) ->
         (exists c F RL n, 
            heapLookup H l = Some (c, F, RL) /\
            RL r = Some (LReaders n) /\
            length (filter (lock_eq (l, r)) (t_rlocks T1 ++ t_rlocks T2)) <= n)) ->
    P / (H, V, n, T1) ==> (H', V', n', T1') ->
    wfLocking H' T2.
Proof with eauto using wfLocking_heapExtend, wfLocking_heapUpdate.
  introv wfCfg wfL2 Hdisj wfRl Hstep.
  assert(wfLs2: wfHeldLocks H (heldLocks T2))
    by eauto using wfLocking_wfHeldLocks.
  inverts wfLs2 as wfLs2.
  assert(wfRl2: wfRLocks H T2)
    by eauto using wfLocking_wfRLocks.
  inverts wfRl2 as wfRl2.
  rewrite Forall_forall in wfLs2.
  inverts wfCfg as Hlt wfH wfV wfT wfL.
  inverts Hdisj as Hdisj1 Hdisj2.
  gen T1' t.
  induction T1; intros.
  + inv_step.
  + inverts wfT as Hfree Hfresh hasType.
    gen T1'. hasType_cases (induction hasType) Case;
      intros; simpls;
      try(destruct_var; try(congruence));
      try(trivial_step_case).
    - Case "T_New". 
      inv_step; try(malformed_context)...
    - Case "T_Call".
      inv_step; try(malformed_context)...
      inv Hfresh.
      apply wfLocking_econtext in wfL...
      inv_eq. apply IHhasType in Hstep...
    - Case "T_ConsmueField".
      inv_step; try(malformed_context)... 
      eapply wfLocking_heapUpdate...
      * introv HIn. apply wfLs2 in HIn...
        inv HIn... rewrite_and_invert.
      * introv HIn.
        apply wfRl2 in HIn as (c' & F' & RL' & n & Hlookup & HRL & Hle)...
        rewrite_and_invert...
    - Case "T_Update".
      inv_step; try(malformed_context)... 
      inv Hfresh.
      apply wfLocking_econtext in wfL...
      inv_eq. apply IHhasType2 in Hstep...
      eapply wfLocking_heapUpdate...
      * introv HIn. apply wfLs2 in HIn...
        inv HIn... rewrite_and_invert.
      * introv HIn.
        apply wfRl2 in HIn as (c' & F' & RL' & n & Hlookup & HRL & Hle)...
        rewrite_and_invert...
    - Case "T_Let". 
      inv_step; try(malformed_context)...
      inv Hfresh.
      apply wfLocking_econtext with (ctx := ctx_let x frame body) in wfL...
      apply app_eq_nil in Hfree as [].
      inv_eq. apply IHhasType1 in Hstep...
      introv HIn. apply in_app_or in HIn...
      inv HIn.
      * assert (HIn': In (l0, r) ((rlocks e ++ rlocks body) ++ t_rlocks T2))
          by eauto using in_or_app...
        apply wfRl in HIn' as (c & F & RL & n'' & Hlookup & HRL & Hle)...
        exists c F RL n''.
        splits...
        inverts H0 as _ no_rlocks. rewrite no_rlocks in Hle. 
        rewrite app_nil_r in Hle...
      * assert (HIn': In (l0, r) ((rlocks e ++ rlocks body) ++ t_rlocks T2))
          by eauto using in_or_app...
        apply wfRl in HIn' as (c & F & RL & n'' & Hlookup & HRL & Hle)...
        exists c F RL n''.
        splits...
        inverts H0 as _ no_rlocks. rewrite no_rlocks in Hle.
        rewrite app_nil_r in Hle...
    - Case "T_Cast".
      inv_step; try(malformed_context)...
      inv Hfresh.
      apply wfLocking_econtext in wfL...
      inv_eq. apply IHhasType in Hstep...
    - Case "T_WLock".
      inv_step; try(malformed_context)...
      eapply wfLocking_heapUpdate...
      * introv HIn. apply wfLs2 in HIn...
        inv HIn... rewrite_and_invert...
        case_extend.
      * introv HIn.
        pose proof (wfRl2 _ _ HIn) as (c' & F' & RL' & n & Hlookup & HRL & Hle).
        apply filter_in with (p := lock_eq) in HIn; eauto using lock_eq_eq.
        assert (Hlen: length (filter (lock_eq (l0, r0)) (t_rlocks T2)) > 0)
          by (destruct (filter (lock_eq (l0, r0)) (t_rlocks T2)); simpls; try(inv HIn); omega).
        rewrite_and_invert.
        case_extend...
        rewrite_and_invert.
        repeat eexists... omega.
    - Case "T_RLock".
      inv_step; try(malformed_context)...
      eapply wfLocking_heapUpdate...
      * introv HIn. apply wfLs2 in HIn...
        inv HIn... rewrite_and_invert.
        case_extend.
      * introv HIn. apply wfRl2 in HIn as (c' & F' & RL' & n & Hlookup & HRL & Hle)...
        rewrite_and_invert.
        case_extend...
        rewrite_and_invert.
        eexists...
    - Case "T_WLocked".
      inv Hfresh.
      apply wfLocking_econtext in wfL...
      inv_step; try(malformed_context); try(inv_eq)... 
      eapply wfLocking_heapUpdate...
      * introv HIn.
        {case_extend.
         + apply Hdisj1 in HIn... inv HIn.
         + apply wfLs2 in HIn. inv HIn. rewrite_and_invert.
        }
      * introv HIn. apply wfRl2 in HIn as (c' & F' & RL' & n & Hlookup & HRL & Hle)...
        rewrite_and_invert.
        case_extend...
    - Case "T_RLocked".
      inv Hfresh.
      apply wfLocking_econtext in wfL...
      inv_step; try(malformed_context); try(inv_eq)... 
      * apply IHhasType2 in Hstep...
        introv HIn.
        assert (HIn': (l0, r) = (l1, r0) \/ In (l1, r0) (rlocks e ++ t_rlocks T2))...
        apply wfRl in HIn' as (c' & F' & RL' & n'' & Hlookup & HRL & Hle)...
        repeat eexists...
        cases_if; simpls;
        omega.
      * {eapply wfLocking_heapUpdate...
         + introv HIn.
           case_extend.
           - apply wfLs2 in HIn. inv HIn. rewrite_and_invert.
             congruence.
           - apply wfLs2 in HIn. inv HIn. rewrite_and_invert.
         + introv HIn.
           simpls.
           assert(HIn': (l0, r) = (l0, r0) \/ In (l0, r0) (t_rlocks T2))...
           apply wfRl in HIn' as (c' & F' & RL' & n & Hlookup & HRL & Hle)...
           case_extend.
           - rewrite_and_invert. rewrite_and_invert.
             rewrite <- beq_nat_refl in Hle.
             destruct r0; simpls.
             rewrite <- beq_nat_refl in Hle.
             exists (pred m). split...
             simpls. omega.
           - rewrite_and_invert.
             exists n. split...
             cases_if; simpls;
             omega.
        }
  + inverts wfT.
    inverts wfL.
    inv_step...
    - eapply IHT1_1; simpls...
      * introv HIn.
        assert(HIn': In (l, r) ((t_rlocks T1_1 ++ t_rlocks T1_2 ++ rlocks e) ++ t_rlocks T2)).
        apply in_app_or in HIn. inv HIn; eauto using in_or_app...
        apply wfRl in HIn' as (c' & F' & RL' & n'' & Hlookup & HRL & Hle)...
        repeat eexists...
        rewrite filter_app.
        rewrite app_length.
        rewrite filter_app in Hle.
        rewrite filter_app in Hle.
        rewrite app_length in Hle.
        rewrite app_length in Hle. omega.
      * introv HIn.
        apply Hdisj1...
        apply in_or_app...
      * introv HIn.
        apply Hdisj2 in HIn.
        apply not_in_app in HIn as []...
    - eapply IHT1_2; simpls...
      * introv HIn.
        assert(HIn': In (l, r) ((t_rlocks T1_1 ++ t_rlocks T1_2 ++ rlocks e) ++ t_rlocks T2)).
        apply in_app_or in HIn. inv HIn; eauto using in_or_app...
        apply in_or_app; left.
        apply in_or_app; right.
        eauto using in_or_app.
        apply wfRl in HIn' as (c' & F' & RL' & n'' & Hlookup & HRL & Hle)...
        repeat eexists...
        rewrite filter_app.
        rewrite app_length.
        rewrite filter_app in Hle.
        rewrite filter_app in Hle.
        rewrite filter_app in Hle.
        rewrite app_length in Hle.
        rewrite app_length in Hle.
        rewrite app_length in Hle. omega.
      * introv HIn.
        apply Hdisj1...
        apply in_or_app...
      * introv HIn.
        apply Hdisj2 in HIn.
        apply not_in_app in HIn as []...
Qed.

Lemma spawn_no_locks :
  forall P Gamma e t H V n Ls e1 e2 e3,
    P; Gamma |- e \in t ->
    P / (H, V, n, T_Thread Ls e) ==>
      (H, V, n, T_Async (T_Thread Ls e1) (T_Thread nil e2) e3) ->
    no_locks e1 /\ no_locks e2.
Proof with eauto.
  introv hasType Hstep.
  gen e1 e2 e3.
  hasType_cases (induction hasType) Case; intros;
  inv_step; try(malformed_context); try(inv_eq)...
Qed.

Lemma spawn_locks :
  forall P Gamma e t H V n Ls e1 e2 e3,
    P; Gamma |- e \in t ->
    P / (H, V, n, T_Thread Ls e) ==>
      (H, V, n, T_Async (T_Thread Ls e1) (T_Thread nil e2) e3) ->
    wlocks e = wlocks e3 /\ rlocks e = rlocks e3.
Proof with eauto.
  introv hasType Hstep.
  gen e1 e2 e3.
  hasType_cases (induction hasType) Case; intros;
  try(solve[inv_step; malformed_context; simpls; inv_eq; eauto]). 
  - inv_step; try(malformed_context); simpls...
    inv_eq. apply IHhasType1 in Hstep...
    inverts H0 as no_wlocks no_rlocks. rewrite no_wlocks. rewrite no_rlocks.
    repeat rewrite app_nil_r...
  - inv_step; try(malformed_context)...
    simpls. inverts H1 as no_wlocks1 no_rlocks1. 
    inverts H2 as no_wlocks2 no_rlocks2. inverts H3 as no_wlocks3 no_rlocks3.
    rewrite no_wlocks1. rewrite no_wlocks2. rewrite no_wlocks3. 
    rewrite no_rlocks1. rewrite no_rlocks2. rewrite no_rlocks3...
  - inv_step; try(malformed_context)...
    inv_eq. simpls. apply IHhasType2 in Hstep...
    inverts Hstep as Hwlocks Hrlocks.
    rewrite Hwlocks. rewrite Hrlocks...
  - inv_step; try(malformed_context)...
    inv_eq. simpls. apply IHhasType2 in Hstep...
    inverts Hstep as Hwlocks Hrlocks.
    rewrite Hwlocks. rewrite Hrlocks...
Qed.

Lemma noLostLocks :
  forall P Gamma l r H H' V V' n n' T T' t,
    In (l, r) (leftmost_locks T) ->
    ~ In (l, r) (t_wlocks T) ->
    wfConfiguration P Gamma (H, V, n, T) t ->
    P / (H, V, n, T) ==> (H', V', n', T') ->
    In (l, r) (leftmost_locks T').
Proof with eauto.
  introv HIn HnIn wfCfg Hstep.
  gen T' t. induction T; intros.
  + inv_step.
  + inverts wfCfg as Hlt wfH wfV wfT wfL.
    inverts wfL as wfLs Hdup wfWl wfRl.
    inverts wfT as Hfree Hfresh hasType.
    gen T'.
    hasType_cases (induction hasType) Case; intros;
    try(trivial_step_case).
    - Case "T_Call". 
      inv_step; try(malformed_context)...
      inv_eq; simpl... 
      inv Hfree. destruct_var; try(congruence).
      inv Hfresh. 
      apply wfWLocks_econtext in wfWl...
      apply wfRLocks_econtext in wfRl...
      eapply IHhasType in Hstep...
    - Case "T_Update". 
      inv_step; try(malformed_context)...
      inv_eq; simpl... 
      inv Hfree. destruct_var; try(congruence).
      inv Hfresh. 
      apply wfWLocks_econtext in wfWl...
      apply wfRLocks_econtext in wfRl...
      eapply IHhasType2 in Hstep...
    - Case "T_Let". 
      inv_step; try(malformed_context)...
      inv_eq; simpls... 
      inv Hfree. apply app_eq_nil in H2 as [].
      inv Hfresh. 
      apply wfWLocks_econtext with (ctx := ctx_let x frame body) in wfWl...
      apply wfRLocks_econtext with (ctx := ctx_let x frame body) in wfRl...
      apply not_in_app in HnIn as [].
      eapply IHhasType1 in Hstep...
    - Case "T_Cast". 
      inv_step; try(malformed_context)...
      inv_eq; simpls... 
      inv Hfree. 
      inv Hfresh. 
      apply wfWLocks_econtext in wfWl...
      apply wfRLocks_econtext in wfRl...
      eapply IHhasType in Hstep...
    - Case "T_WLock". 
      inv_step; try(malformed_context)...
      simpls...
    - Case "T_WLocked". 
      inv_step; try(malformed_context); simpls...
      * inv_eq.
        inv Hfree. inv Hfresh. 
        apply wfWLocks_econtext in wfWl...
        apply wfRLocks_econtext in wfRl...
        eapply IHhasType2 in Hstep...
      * clear IHhasType1. clear IHhasType2.
        assert ((l1, r0) <> (l, r))...
        apply remove_in_neq...
    - Case "T_RLocked". 
      inv_step; try(malformed_context); simpls...
      inv_eq; simpl...
      inv Hfree. inv Hfresh.
      eapply wfWLocks_econtext in wfWl...
      eapply wfRLocks_econtext in wfRl...
      apply IHhasType2 in Hstep...
  + inverts wfCfg as Hlt wfH wfV wfT wfL.
    inverts wfT as Hfree Hfresh hasType wfT1 wfT2.
    inverts wfL as wfWl HWdisj wfRl Hdisj wfL1 wfL2.
    inv_step...
    - simpls...
      eapply IHT1 in Hstep...
      apply not_in_app in HnIn as []...
Qed.

Lemma noDuplicatedLocks :
  forall P t' Gamma l r H H' V V' n n' T T' t c F RL,
    wfProgram P t' ->
    heapLookup H l = Some (c, F, RL) ->
    RL r = Some LLocked ->
    ~ In (l, r) (t_wlocks T) ->
    wfConfiguration P Gamma (H, V, n, T) t ->
    P / (H, V, n, T) ==> (H', V', n', T') ->
    ~ In (l, r) (t_wlocks T').
Proof with eauto.
  introv wfP Hlookup HRL HnIn wfCfg Hstep.
  gen T' t. induction T; intros.
  + inv_step.
  + rename l0 into Ls.
    inverts wfCfg as Hlt wfH wfV wfT wfL.
    inverts wfL as wfLs Hdup wfWl wfRl.
    inverts wfT as Hfree Hfresh hasType.
    gen T'.
    hasType_cases (induction hasType) Case; intros;
    try(trivial_step_case).
    - Case "T_Call". 
      inv Hfree. destruct_var; try(congruence).
      inv Hfresh.
      apply wfWLocks_econtext in wfWl...
      apply wfRLocks_econtext in wfRl...
      inv_step; try(malformed_context); try(inv_eq); simpls...
      * eapply IHhasType in Hstep...
      * eapply IHhasType in Hstep...
      * rewrite <- wlocks_subst. rewrite <- wlocks_subst.
        rewrite <- wlocks_sigma. 
        eapply wfProgram_wfMethodDecl in H21... 
        inv H21. apply wlocks_static in H15. rewrite H15. 
        contra...
    - Case "T_Update". 
      inv Hfree. destruct_var; try(congruence).
      inv Hfresh.
      apply wfWLocks_econtext in wfWl...
      apply wfRLocks_econtext in wfRl...
      inv_step; try(malformed_context); try(inv_eq); simpls...
      * eapply IHhasType2 in Hstep...
      * eapply IHhasType2 in Hstep...
    - Case "T_Let". 
      inv Hfree. inv Hfresh.
      apply wfWLocks_econtext with (ctx := ctx_let x frame body) in wfWl...
      apply wfRLocks_econtext with (ctx := ctx_let x frame body) in wfRl...
      inv H0.
      apply not_in_app in HnIn as [].
      apply app_eq_nil in H2 as [].
      inv_step; try(malformed_context); try(inv_eq); simpls...
      * eapply IHhasType1 in Hstep...
        rewrite H1. rewrite app_nil_r...
      * eapply IHhasType1 in Hstep...
        rewrite H1. rewrite app_nil_r...
      * rewrite <- wlocks_subst. rewrite H1. 
        contra...
    - Case "T_Cast". 
      inv Hfree. inv Hfresh.
      apply wfWLocks_econtext in wfWl...
      apply wfRLocks_econtext in wfRl...
      inv_step; try(malformed_context); try(inv_eq); simpls...
      * eapply IHhasType in Hstep...
      * eapply IHhasType in Hstep...
    - Case "T_WLock". 
      inv_step; try(malformed_context)...
      clears IHhasType1 IHhasType2.
      simpls... contra... 
      inv_eq. rewrite_and_invert.
      congruence.
    - Case "T_WLocked". 
      inv Hfree. inv Hfresh.
      apply wfWLocks_econtext in wfWl...
      apply wfRLocks_econtext in wfRl...
      inv_step; try(malformed_context); try(inv_eq); simpls...
      * eapply IHhasType2 in Hstep...
        simpls. apply not_in_app in Hstep as [].
        apply not_in_app in H0 as [].
        apply not_in_app.
        split...
        apply not_in_app.
        split... 
        contra...
      * eapply IHhasType2 in Hstep...
        contra...
    - Case "T_RLocked". 
      inv Hfree. inv Hfresh.
      apply wfWLocks_econtext in wfWl...
      apply wfRLocks_econtext in wfRl...
      inv_step; try(malformed_context); try(inv_eq); simpls...
      * eapply IHhasType2 in Hstep...
      * eapply IHhasType2 in Hstep...
  + inverts wfCfg as Hlt wfH wfV wfT wfL.
    inverts wfT as Hfree Hfresh hasType wfT1 wfT2.
    inverts wfL as wfWl HWdisj wfRl Hdisj wfL1 wfL2.
    inv_step...
    - simpls...
      apply not_in_app in HnIn as []...
      apply not_in_app...
    - simpls...
      apply not_in_app in HnIn as []...
      apply not_in_app...
      split...
      apply not_in_app in H1 as []...
      apply not_in_app...
    - simpls.
      apply not_in_app in HnIn as [_ HnIn'].
      apply not_in_app in HnIn' as []...
Qed.

Lemma noLostRLocks :
  forall P t' Gamma l r c F RL n'' RLs H H' V V' n n' Ls Ls' e e' t m,
    wfProgram P t' ->
    heapLookup H l = Some (c, F, RL) ->
    RL r = Some (LReaders n'') ->
    0 < m ->
    m + (length (filter (lock_eq (l, r)) (rlocks e ++ RLs))) <= n'' ->
    wfThreads P Gamma n (T_Thread Ls e) t ->
    P / (H, V, n, T_Thread Ls e) ==> (H', V', n', T_Thread Ls' e') ->
    exists F' RL' n''', 
      heapLookup H' l = Some (c, F', RL') /\
      RL' r = Some (LReaders n''') /\
      m + (length (filter (lock_eq (l, r)) (rlocks e' ++ RLs))) <= n'''.
Proof with eauto.
  introv wfP Hlookup HRL Hm Hle wfT Hstep.
  assert(l < length H)
    by (eapply heapLookup_lt; eauto).
  inverts wfT as Hfree Hfresh hasType.
  gen e' m. hasType_cases (induction hasType) Case; simpls; intros;
            try(trivial_step_case); repeat(destruct_var; try(congruence)).
  + Case "T_Var". 
    inv_step; try(malformed_context)...
    repeat eexists...
  + Case "T_Consume". 
    inv_step; try(malformed_context)...
    repeat eexists...
  + Case "T_New". 
    inv_step; try(malformed_context)...
    rewrite heapExtend_lookup_nlen...
    repeat eexists...
    omega.
  + Case "T_Call". 
    inv Hfresh.
    inv_step; try(malformed_context);
    simpls; try(inv_eq)...
    rewrite <- rlocks_subst.
    rewrite <- rlocks_subst.
    rewrite <- rlocks_sigma.
    assert (wfMtd: wfMethodDecl P c0 (Method m (y0, t0) t'0 body))
      by eauto using wfProgram_wfMethodDecl.
    inv wfMtd.
    rewrite rlocks_static...
    simpl. repeat eexists...
  + Case "T_Select". 
    inv_step; try(malformed_context);
    simpls; try(inv_eq)...
    repeat eexists...
  + Case "T_ConsmueField". 
    inv_step; try(malformed_context);
    simpls; try(inv_eq)...
    destruct (id_eq_dec l0 l).
    - subst. rewrite lookup_heapUpdate_eq...
      rewrite_and_invert.
      repeat eexists...
    - rewrite lookup_heapUpdate_neq...
      repeat eexists...
  + Case "T_Update". 
    inv Hfresh.
    inv_step; try(malformed_context);
    simpls; try(inv_eq)...
    destruct (id_eq_dec l0 l).
    - subst. rewrite lookup_heapUpdate_eq...
      rewrite_and_invert.
      repeat eexists...
    - rewrite lookup_heapUpdate_neq...
      repeat eexists...
  + Case "T_Let". 
    inv Hfresh.
    inverts H1 as _ no_rlocks.
    rewrite no_rlocks in Hle. rewrite app_nil_r in Hle...
    apply app_eq_nil in Hfree as [].
    inv_step; try(malformed_context);
    simpls; try(inv_eq)...
    - rewrite no_rlocks. rewrite app_nil_r.
      eapply IHhasType1 in Hstep...
    - rewrite <- rlocks_subst.
      rewrite no_rlocks.
      repeat eexists...
  + Case "T_Cast". 
    inv Hfresh.
    inv_step; try(malformed_context);
    simpls; try(inv_eq)...
    repeat eexists...
  + Case "T_WLock". 
    inv Hfresh.
    inv_step; try(malformed_context);
    simpls; try(inv_eq)...
    - destruct (id_eq_dec l0 l).
      * subst. rewrite_and_invert.
        rewrite lookup_heapUpdate_eq...
        repeat eexists...
        case_extend. rewrite_and_invert.
        destruct m; try
        omega. 
      * rewrite lookup_heapUpdate_neq...
        repeat eexists...
    - repeat eexists...
  + Case "T_RLock". 
    inv Hfresh.
    inv_step; try(malformed_context);
    simpls; try(inv_eq)...
    - destruct (id_eq_dec l l0).
      * subst. rewrite_and_invert.
        rewrite lookup_heapUpdate_eq...
        {destruct (id_eq_dec r0 r).
         + subst. rewrite_and_invert.
           folds (lock_eq (l0, r) (l0, r)).
           rewrite lock_eq_refl. simpls.
           repeat eexists...
           omega.
         + replaces (region_id_eq r r0) with false;
           try(solve[destruct r; destruct r0; simpls;
                     apply beq_nat_false_iff; eauto]).
           rewrite <- beq_nat_refl.
           simpl. repeat eexists... case_extend.
        }
      * rewrite lookup_heapUpdate_neq...
        repeat eexists...
        apply beq_nat_false_iff in n.
        rewrite n. simpl.
        omega.
    - repeat eexists...
  + Case "T_WLocked". 
    inv Hfresh.
    inv_step; try(malformed_context);
    simpls; try(inv_eq)...
    destruct (id_eq_dec l l0).
    - subst. rewrite_and_invert.
      rewrite lookup_heapUpdate_eq...
      destruct (id_eq_dec r0 r).
      * subst. rewrite_and_invert.
      * repeat eexists... case_extend.
    - rewrite lookup_heapUpdate_neq...
      repeat eexists...
  + Case "T_RLocked". 
    inv Hfresh.
    inv_step; try(malformed_context);
    simpls; try(inv_eq)...
    - cases_if; simpls.
      * apply IHhasType2 with (m := S m) in Hstep as (F' & RL' & n''' & Hlookup' & HRL' & Hle');
        try omega...
        repeat eexists... omega.
      * eapply IHhasType2 in Hstep...
    - folds (lock_eq (l, r) (l0, r0)).
      cases_if.
      * apply lock_eq_eq in H1.
        inv_eq. simpls.
        rewrite lookup_heapUpdate_eq...
        rewrite_and_invert.
        rewrite_and_invert.
        repeat eexists...
        omega.
      * {destruct (id_eq_dec l l0).
         + subst. rewrite_and_invert.
           rewrite lookup_heapUpdate_eq...
           destruct (id_eq_dec r0 r).
           - subst. rewrite_and_invert.
             repeat eexists...
              assert (lock_eq (l0, r) (l0, r) = true)
                by (eapply lock_eq_eq; eauto).
              congruence.
           - repeat eexists... case_extend.
         + rewrite lookup_heapUpdate_neq...
           repeat eexists...
        }
  + Case "T_Assert". 
    inv_step; try(malformed_context);
    simpls; try(inv_eq)...
    repeat eexists...
Qed.

Lemma wfRLocks_async_preservation :
  forall P t' Gamma H H' V V' n n' T T' t RLs l r,
    wfProgram P t' ->
    wfConfiguration P Gamma (H, V, n, T) t ->
    (In (l, r) (t_rlocks T ++ RLs) -> 
     exists c F RL n,
       heapLookup H l = Some (c, F, RL) /\
       RL r = Some (LReaders n) /\
       length (filter (lock_eq (l, r)) (t_rlocks T ++ RLs)) <= n) ->
    P / (H, V, n, T) ==> (H', V', n', T') ->
    (In (l, r) (t_rlocks T' ++ RLs) -> 
     exists c F RL n,
       heapLookup H' l = Some (c, F, RL) /\
       RL r = Some (LReaders n) /\
       length (filter (lock_eq (l, r)) (t_rlocks T' ++ RLs)) <= n).    
Proof with eauto. 
  introv wfP wfCfg wfRl Hstep HIn.
  gen T' t RLs. induction T; intros; simpls.
  + inv_step.
  + rename l0 into Ls. 
    inverts wfCfg as Hlt wfH wfV wfT wfL.
    inverts wfL as wfLs Hdup wfWl wfRl'. 
    inversion wfWl. inversion wfRl'.
    inverts wfT as Hfree Hfresh hasType.
    gen T'.
    hasType_cases (induction hasType) Case; intros; simpls;
    try(trivial_step_case).
    - Case "T_New". 
      inv_step; try(malformed_context)... simpls. 
      apply wfRl in HIn as (c' & F' & RL' & n'' & Hlookup & HRL & Hle). 
      assert(l < length H)
        by (eapply heapLookup_lt; eauto).
      assert(l <> length H)
        by omega.
      rewrite heapExtend_lookup_nlen... repeat eexists... 
    - Case "T_Call".
      destruct_var; try(congruence). 
      inv Hfresh.
      inv_step; try(malformed_context); simpls; try inv_eq... 
      * apply IHhasType in Hstep...
      * apply IHhasType in Hstep...
      * assert (wfMtd: wfMethodDecl P c (Method m (y0, t0) t'0 body)) by eauto using wfProgram_wfMethodDecl.
        inv wfMtd.
        rewrite <- rlocks_subst. rewrite <- rlocks_subst. 
        rewrite <- rlocks_sigma. rewrite rlocks_static...
        rewrite <- rlocks_subst in HIn. rewrite <- rlocks_subst in HIn. 
        rewrite <- rlocks_sigma in HIn. rewrite rlocks_static in HIn...
      * assert(HIn': In (l, r) (rlocks e ++ RLs))
          by eauto using in_or_app.
        apply wfRl in HIn' as (c' & F' & RL' & n'' & Hlookup & HRL & Hle).
        rewrite filter_app in Hle.
        rewrite app_length in Hle.
        repeat eexists... omega.
    - Case "T_ConsmueField". 
      destruct_var; try(congruence). 
      inv_step; try(malformed_context); simpls; try inv_eq... 
      destruct (id_eq_dec l0 l).
      * subst. rewrite lookup_heapUpdate_eq; try eapply heapLookup_lt...
        apply wfRl in HIn as (c' & F' & RL' & n'' & Hlookup & HRL & Hle).
        rewrite_and_invert.
        repeat eexists...
      * rewrite lookup_heapUpdate_neq...
    - Case "T_Update". 
      destruct_var; try(congruence). 
      inv Hfresh.
      inv_step; try(malformed_context); simpls; try inv_eq... 
      * apply IHhasType2 in Hstep...
      * apply IHhasType2 in Hstep...
      * {destruct (id_eq_dec l0 l).
         + subst. rewrite lookup_heapUpdate_eq; try eapply heapLookup_lt...
           apply wfRl in HIn as (c' & F' & RL' & n'' & Hlookup & HRL & Hle).
           rewrite_and_invert.
           repeat eexists...
         + rewrite lookup_heapUpdate_neq...
        }
      * assert(HIn': In (l, r) (rlocks e ++ RLs))
          by eauto using in_or_app.
        apply wfRl in HIn' as (c' & F' & RL' & n'' & Hlookup & HRL & Hle).
        rewrite filter_app in Hle.
        rewrite app_length in Hle.
        repeat eexists... omega.
    - Case "T_Let".
      inv Hfresh. inverts H3 as _ no_rlocks.
      rewrite no_rlocks in wfRl. rewrite app_nil_r in wfRl. 
      apply app_eq_nil in Hfree as [].
      apply wfWLocks_econtext with (ctx := ctx_let x frame body) in wfWl...
      apply wfRLocks_econtext with (ctx := ctx_let x frame body) in wfRl'...
      inv wfWl.
      inv wfRl'.
      inv_step; try(malformed_context); simpls; try inv_eq... 
      * rewrite no_rlocks. rewrite app_nil_r. 
        rewrite no_rlocks in HIn. rewrite app_nil_r in HIn. 
        apply IHhasType1 in Hstep...
      * rewrite no_rlocks. rewrite app_nil_r. 
        rewrite no_rlocks in HIn. rewrite app_nil_r in HIn. 
        apply IHhasType1 in Hstep...
      * rewrite <- rlocks_subst. rewrite no_rlocks. simpl. 
        rewrite <- rlocks_subst in HIn.
        rewrite no_rlocks in HIn. simpls.
        apply wfRl in HIn as (c' & F' & RL' & n'' & Hlookup & HRL & Hle).
        repeat eexists...
      * assert(HIn': In (l, r) (rlocks e ++ RLs))
          by eauto using in_or_app.
        apply wfRl in HIn' as (c' & F' & RL' & n'' & Hlookup & HRL & Hle).
        rewrite filter_app in Hle.
        rewrite app_length in Hle.
        repeat eexists... omega. 
    - Case "T_Cast". 
      inv Hfresh.
      inv_step; try(malformed_context); simpls; try inv_eq... 
      * apply IHhasType in Hstep...
      * apply IHhasType in Hstep...
      * assert(HIn': In (l, r) (rlocks e ++ RLs))
          by eauto using in_or_app.
        apply wfRl in HIn' as (c' & F' & RL' & n'' & Hlookup & HRL & Hle).
        rewrite filter_app in Hle.
        rewrite app_length in Hle.
        repeat eexists... omega.
    - Case "T_WLock".
      clears IHhasType1 IHhasType2.
      inv_step; try(malformed_context); simpls... 
      pose proof (wfRl HIn) as (c' & F' & RL' & n'' & Hlookup & HRL & Hle).
      * {destruct (id_eq_dec l0 l). 
         + subst. 
           rewrite lookup_heapUpdate_eq; try eapply heapLookup_lt...
           repeat eexists...
           case_extend. rewrite_and_invert. 
           rewrite_and_invert. 
           assert (length (filter (lock_eq (l, r)) (rlocks e ++ RLs)) = 0) by omega.
           assert (Hnil: filter (lock_eq (l, r)) (rlocks e ++ RLs) = nil) by
             (destruct(filter (lock_eq (l, r)) (rlocks e ++ RLs)); simpls; congruence). 
           rewrite filter_in with (p := lock_eq) in HIn.
           rewrite Hnil in HIn. inv HIn. apply lock_eq_eq.
         + rewrite lookup_heapUpdate_neq...
        }
      * assert(HIn': In (l, r) (rlocks e ++ RLs))
          by eauto using in_or_app.
        apply wfRl in HIn' as (c' & F' & RL' & n'' & Hlookup & HRL & Hle).
        repeat eexists...
        rewrite filter_app in Hle.
        rewrite app_length in Hle. omega.
    - Case "T_RLock". 
      clears IHhasType1 IHhasType2.
      inv_step; try(malformed_context); simpls... 
      * {inv HIn.
         + inv_eq. rewrite <- beq_nat_refl. rewrite region_id_eq_refl.
           simpl. rewrite lookup_heapUpdate_eq; try(apply heapLookup_lt)...
           repeat eexists...
           assert(InOrNot: {In (l, r) (rlocks e ++ RLs)} + {~In (l, r) (rlocks e ++ RLs)})
             by (eapply in_dec; eapply id_eq_dec).
           inv InOrNot... 
           - apply wfRl in H6 as (c' & F' & RL' & n'' & Hlookup & HRL & Hle).
             rewrite_and_invert. rewrite_and_invert. omega.
           - rewrite filter_not_in in H6; try(apply lock_eq_eq).
             replaces (filter (lock_eq (l, r)) (rlocks e ++ RLs)) with (@nil lock)... 
             simpl. omega.
         + apply wfRl in H6 as (c' & F' & RL' & n'' & Hlookup & HRL & Hle).
           destruct (id_eq_dec l l0).
           - subst. rewrite_and_invert. 
             rewrite lookup_heapUpdate_eq; try(apply heapLookup_lt)...
             rewrite <- beq_nat_refl.
             destruct (id_eq_dec r r0). 
             * subst. rewrite_and_invert.
               rewrite region_id_eq_refl.
               simpl. repeat eexists... omega. 
             * replaces (region_id_eq r r0) with false;
               try(solve[destruct r; destruct r0; simpls;
                         apply beq_nat_false_iff; eauto]).
               simpl. exists c' F' (extend RL' r0 (LReaders (S m))) n''.
               splits... case_extend.
           - rewrite lookup_heapUpdate_neq...
             replaces (beq_nat l l0) with false;
               try(apply beq_nat_false_iff; eauto).
             simpl. repeat eexists...
        }
      * assert(HIn': In (l, r) (rlocks e ++ RLs))
          by eauto using in_or_app.
        apply wfRl in HIn' as (c' & F' & RL' & n'' & Hlookup & HRL & Hle).
        repeat eexists...
        rewrite filter_app in Hle.
        rewrite app_length in Hle. omega.
    - Case "T_WLocked".
      inv Hfresh.
      assert (wfRLocks H (T_Thread Ls e))
        by (apply wfRLocks_econtext in wfRl'; eauto).
      assert (NoDup (wlocks e))
        by (inv H1; eauto).
      inv_step; try(malformed_context); simpls...
      * inv_eq. 
        assert(Hno_locks: no_locks e1 /\ no_locks e2)
          by eauto using spawn_no_locks.
        assert(Hlocks: rlocks (ERlocked (l0, r0) e) = rlocks (ERlocked (l0, r0) e3))
          by (eapply spawn_locks; eauto).
        inverts Hno_locks as no_locks1 no_locks2.
        inverts no_locks1 as _ no_rlocks1.
        inverts no_locks2 as _ no_rlocks2.
        inverts Hlocks as Hlocks. 
        rewrite no_rlocks1.
        rewrite no_rlocks2.
        rewrite <- Hlocks in HIn. 
        rewrite no_rlocks1 in HIn.
        rewrite no_rlocks2 in HIn.
        simpls.
        apply wfRl in HIn...
      * inv_eq. apply IHhasType2 in Hstep...
      * clears IHhasType1 IHhasType2. 
        apply wfRl in HIn as (c' & F' & RL' & n'' & Hlookup & HRL & Hle).
        {destruct(id_eq_dec l0 l).
         + subst. rewrite lookup_heapUpdate_eq; try eapply heapLookup_lt...
           repeat eexists...
           case_extend.
         + rewrite lookup_heapUpdate_neq...
           repeat eexists...
        }
      * inv_eq. 
        assert(HIn': In (l, r) (rlocks e ++ RLs))
          by eauto using in_or_app.
        apply wfRl in HIn' as (c' & F' & RL' & n'' & Hlookup & HRL & Hle)...
        repeat eexists... 
        rewrite filter_app in Hle. 
        rewrite app_length in Hle. 
        omega.
    - Case "T_RLocked".
      inv Hfresh.
      assert (wfRLocks H (T_Thread Ls e))
        by (apply wfRLocks_econtext in wfRl'; eauto).
      assert (NoDup (wlocks e))
        by (inv H1; eauto).
      inv_step; try(malformed_context); simpls...
      * inv_eq. 
        assert(Hno_locks: no_locks e1 /\ no_locks e2)
          by eauto using spawn_no_locks.
        assert(Hlocks: rlocks (ERlocked (l0, r0) e) = rlocks (ERlocked (l0, r0) e3))
          by (eapply spawn_locks; eauto).
        inverts Hno_locks as no_locks1 no_locks2.
        inverts no_locks1 as _ no_rlocks1.
        inverts no_locks2 as _ no_rlocks2.
        inverts Hlocks as Hlocks. 
        rewrite no_rlocks1.
        rewrite no_rlocks2.
        rewrite <- Hlocks in HIn. 
        rewrite no_rlocks1 in HIn.
        rewrite no_rlocks2 in HIn.
        simpls.
        apply wfRl in HIn... 
      * inv_eq. 
        {inv HIn.
         + inv_eq.
           folds (lock_eq (l, r) (l, r)).
           rewrite lock_eq_refl.
           rewrite lock_eq_refl in wfRl.
           simpls.
           assert(HIn': (l, r) = (l, r) \/ In (l, r) (rlocks e ++ RLs))...
           apply wfRl in HIn' as (c & F & RL & n'' & Hlookup & HRL & Hle)... 
           eapply noLostRLocks with (m := 1) in Hstep...
         + assert(Hstep': P / (H, V, n, T_Thread Ls e) ==> (H', V', n', T_Thread Ls' e'))... 
           apply IHhasType2 in Hstep as (c' & F' & RL' & n'' & Hlookup & HRL & Hle)...
           - cases_if; simpls.
             * folds (lock_eq (l, r) (l0, r0)). 
               apply lock_eq_eq in H7. inv_eq.
               assert (HIn': (l0, r0) = (l0, r0) \/ In (l0, r0) (rlocks e ++ RLs))... 
               apply wfRl in HIn' as (c & F & RL & n''' & Hlookup' & HRL' & Hle').
               eapply noLostRLocks with (m := 1) in Hstep'... 
             * repeat eexists... 
           - introv HIn.
             assert(HIn': (l0, r0) = (l, r) \/ In (l, r) (rlocks e ++ RLs))...
             apply wfRl in HIn' as (c' & F' & RL' & n'' & Hlookup & HRL & Hle)...
             repeat eexists...
             cases_if; simpls; omega.
           - introv HIn. inverts wfRl' as wfRl'. simpls.
             assert(HIn': (l0, r0) = (l1, r1) \/ In (l1, r1) (rlocks e))...
             apply wfRl' in HIn' as (c' & F' & RL' & n'' & Hlookup & HRL & Hle)...
             repeat eexists...
             cases_if; simpls; omega.
        }
      * clears IHhasType1 IHhasType2.
        assert (HIn': ((l0, r0) = (l, r) \/ In (l, r) RLs))
          by eauto using in_or_app.
        apply wfRl in HIn' as (c' & F' & RL' & n'' & Hlookup & HRL & Hle)...
        {destruct (id_eq_dec l0 l).
         + subst. rewrite lookup_heapUpdate_eq; try(apply heapLookup_lt)...
           rewrite <- beq_nat_refl in Hle. destruct (id_eq_dec r r0).
           - subst. rewrite region_id_eq_refl in Hle. simpls.
             repeat eexists...
             rewrite_and_invert. rewrite_and_invert.
             omega.
           - replaces (region_id_eq r r0) with false in Hle;
               try(solve[destruct r; destruct r0; simpls;
                         apply beq_nat_false_iff; eauto]).
               simpls. exists c F (extend RL r0 (LReaders (pred m))) n''.
               splits... case_extend.
         + rewrite lookup_heapUpdate_neq...
           replaces (beq_nat l l0) with false in Hle;
             try(apply beq_nat_false_iff)...
           simpls. repeat eexists...
        }
      * inv_eq. 
        assert(HIn': (l0, r0) = (l, r) \/ In (l, r) (rlocks e ++ RLs))
          by eauto using in_or_app.
        apply wfRl in HIn' as (c' & F' & RL' & n'' & Hlookup & HRL & Hle)...
        repeat eexists... 
        {cases_if; simpls.
         + apply le_S in Hle.
           apply le_S_n in Hle.
           repeat rewrite filter_app in Hle. 
           repeat rewrite app_length in Hle. 
           omega.
         + repeat rewrite filter_app in Hle. 
           repeat rewrite app_length in Hle. 
           omega.
        }
    - Case "T_Assert". 
      clears IHhasType1 IHhasType2 IHhasType3.
      simpls.
      inv H3. rewrite H5 in wfRl. simpls.
      inv_step; try(malformed_context)... 
      simpls.
      assert(HIn': In (l, r) (rlocks e ++ RLs))
        by eauto using in_or_app.
      rewrite H5 in HIn'. rewrite H5.
      apply wfRl in HIn' as (c' & F' & RL' & n'' & Hlookup & HRL & Hle).
      repeat eexists...
  + inverts wfCfg as Hlt wfH wfV wfT wfL.
    inverts wfT as Hfree Hfresh hasType wfT1 wfT2.
    inverts wfL as wfWl HWdisj wfRl Hdisj wfL1 wfL2.
    inv_step; simpls... 
    - eapply IHT1 
      with (RLs := (t_rlocks T2 ++ rlocks e ++ RLs)) 
        in Hstep as (c' & F' & RL' & n'' & Hlookup & HRL & Hle)...
      * repeat eexists...
        repeat rewrite filter_app.
        repeat rewrite app_length.
        repeat rewrite filter_app in Hle.
        repeat rewrite app_length in Hle. omega.
      * introv HIn'. 
        replaces (filter (lock_eq (l, r)) (t_rlocks T1 ++ t_rlocks T2 ++ rlocks e ++ RLs))
        with (filter (lock_eq (l, r)) ((t_rlocks T1 ++ t_rlocks T2 ++ rlocks e) ++ RLs));
          try(solve[repeat rewrite filter_app; repeat rewrite <- app_assoc; reflexivity]). 
        apply wfRl. repeat rewrite <- app_assoc... 
      * repeat rewrite <- app_assoc in HIn...  
    - eapply IHT2 
      with (RLs := (t_rlocks T1 ++ rlocks e ++ RLs)) 
        in Hstep as (c' & F' & RL' & n'' & Hlookup & HRL & Hle)...
      * repeat eexists...
        repeat rewrite filter_app.
        repeat rewrite app_length.
        repeat rewrite filter_app in Hle.
        repeat rewrite app_length in Hle. omega.
      * introv HIn'. 
        repeat rewrite filter_app.
        repeat rewrite app_length.
        repeat rewrite filter_app in wfRl.
        repeat rewrite app_length in wfRl.
        replace (length (filter (lock_eq (l, r)) (t_rlocks T2)) +
                 (length (filter (lock_eq (l, r)) (t_rlocks T1)) +
                  (length (filter (lock_eq (l, r)) (rlocks e)) +
                   length (filter (lock_eq (l, r)) RLs))))
        with (length (filter (lock_eq (l, r)) (t_rlocks T1)) +
              (length (filter (lock_eq (l, r)) (t_rlocks T2)) +
               length (filter (lock_eq (l, r)) (rlocks e))) +
              length (filter (lock_eq (l, r)) RLs));
          try(omega).
        apply wfRl. repeat rewrite app_assoc in HIn'. 
        apply in_app_or in HIn'. 
        apply in_or_app. inverts HIn' as HIn'... 
        left. apply in_app_or in HIn'. rewrite app_assoc.
        apply in_or_app. inverts HIn' as HIn'... 
        left. apply in_comm... 
      * repeat rewrite app_assoc. apply in_or_app. 
        apply in_app_or in HIn. inverts HIn as HIn...
        left. rewrite app_assoc in HIn. 
        apply in_or_app. apply in_app_or in HIn. 
        inverts HIn as HIn... left. apply in_comm...
    - destruct e1; try(contradiction).
      destruct T2; try(contradiction).
      destruct e0; try(contradiction).
      simpls...
    - assert (HIn': In (l, r) ((t_rlocks T1 ++ t_rlocks T2 ++ rlocks e) ++ RLs))
        by eauto using in_or_app.
      apply wfRl in HIn' as (c' & F' & RL' & n'' & Hlookup & HRL & Hle)...
      repeat eexists...
      repeat rewrite filter_app in Hle.
      rewrite app_length in Hle. omega.
    - assert (HIn': In (l, r) ((t_rlocks T1 ++ t_rlocks T2 ++ rlocks e) ++ RLs))
        by eauto using in_or_app.
      apply wfRl in HIn' as (c' & F' & RL' & n'' & Hlookup & HRL & Hle)...
      repeat eexists...
      repeat rewrite filter_app in Hle.
      rewrite app_length in Hle. omega.
Qed.

Theorem wfLocking_preservation : 
  forall P t' Gamma H H' V V' n n' T T' t,
    wfProgram P t' ->
    wfConfiguration P Gamma (H, V, n, T) t ->
    P / (H, V, n, T) ==> (H', V', n', T') ->
    wfLocking H' T'.
Proof with eauto using wfLocking_heapExtend.
  introv wfP wfCfg Hstep.
  gen H' V' n' T' t.
  induction T; intros.
  + (* EXN does not step *)
    inv_step.
  + rename l into Ls. 
    inverts wfCfg as Hlt wfH wfV wfT wfL.
    inverts wfL as wfLs Hdup wfWl wfRl. 
    inversion wfWl. inversion wfRl.
    inverts wfT as Hfree Hfresh hasType.
    gen T'.
    hasType_cases (induction hasType) Case; intros; simpls;
    assert(Hmono: n <= n') by eauto using step_n_monotonic;
    try(trivial_step_case).
    - Case "T_New". abstract(inv_step; try(malformed_context); eauto using wfLocking_heapExtend).
    - Case "T_Call". 
      destruct_var; try(congruence).
      inv Hfresh.
      inv_step; try(malformed_context); unfold_ctx...      
      * inv_eq. apply IHhasType in Hstep...
        inv Hstep; simpls.
        inv H9.
        inv H12...
      * inv_eq. apply IHhasType in Hstep...
        inv Hstep.
        inv H12.
        inv H13...
      * clear IHhasType. 
        apply wfLocking_subst. apply wfLocking_subst. 
        apply wfLocking_sigma. apply wfLocking_static...
        assert (wfMtd: wfMethodDecl P c (Method m (y0, t0) t'0 body)) by eauto using wfProgram_wfMethodDecl.
        inv wfMtd...
    - Case "T_ConsmueField". 
      destruct_var; try(congruence).
      inv_step; try(malformed_context); unfold_ctx... 
      eapply wfLocking_heapUpdate; simpls...
      introv HIn. eapply wfHeldLocks_taken...
      introv contra. false. 
    - Case "T_Update". 
      destruct_var; try(congruence).
      inv Hfresh.
      inv_step; try(malformed_context); unfold_ctx... 
      * inv_eq. apply IHhasType2 in Hstep...
        inv Hstep... 
        inv H8.
        inv H11...
      * inv_eq. apply IHhasType2 in Hstep...
        inv Hstep.
        inv H11.
        inv H12...
      * eapply wfLocking_heapUpdate; simpls...
        introv HIn. eapply wfHeldLocks_taken...
        introv contra. false. 
    - Case "T_Let".
      inv Hfresh.
      apply app_eq_nil in Hfree as [].
      apply wfWLocks_econtext with (ctx := ctx_let x frame body) in wfWl...
      apply wfRLocks_econtext with (ctx := ctx_let x frame body) in wfRl...
      inv_step; try(malformed_context); unfold_ctx... 
      * inv_eq. 
        inv wfWl. inv wfRl. 
        inv H3.
        apply IHhasType1 in Hstep...
        inv Hstep...
        inv H15.
        inv H17.
        {econstructor...
         + econstructor; simpl...
           rewrite H11.
           rewrite app_nil_r...
           rewrite H11.
           rewrite app_nil_r...
         + introv HIn. simpls.
           apply in_app_or in HIn.
           inv HIn...
           rewrite H11 in H15. inv H15.
         + econstructor; simpl...
           rewrite H12.
           rewrite app_nil_r...
        }
      * inv_eq. 
        inv wfWl. inv wfRl. 
        inv H3.
        apply IHhasType1 in Hstep...
        inv Hstep...
        inv H17.
        inv H18.
        {econstructor...
         + econstructor; simpl...
           rewrite H12.
           rewrite app_nil_r...
           rewrite H12.
           rewrite app_nil_r...
         + econstructor; simpl...
           rewrite H13.
           rewrite app_nil_r...
        }
      * apply wfLocking_subst...
    - Case "T_Cast". 
      inv Hfresh.
      inv_step; try(malformed_context); unfold_ctx... 
      * inv_eq. apply IHhasType in Hstep...
        inv Hstep... 
        inv H7.
        inv H9...
      * inv_eq. apply IHhasType in Hstep...
        inv Hstep.
        inv H9.
        inv H10...
    - Case "T_Par".
      inv_step; try(malformed_context)...
      clears IHhasType1 IHhasType2 IHhasType3.
      inv H4. inv H5. inv H6.
      econstructor...
      * econstructor; simpl; rewrite H5...
        introv contra. inv contra.
      * rewrite H5. introv contra. inv contra.
      * econstructor...
        econstructor; simpl; rewrite H...
        introv contra. inv contra.
        econstructor; simpl; rewrite H7...
        introv contra. inv contra.
      * econstructor...
        econstructor; simpl; rewrite H4...
        econstructor; simpl; rewrite H8...
        introv contra. inv contra.
    - Case "T_WLock".
      inv_step; try(malformed_context)...
      inv H5.
      econstructor...
      * {apply wfHeldLocks_cons.
         + eapply wfHeldLocks_heapUpdate...
           introv HRL.
           case_extend.
           eapply wfHeldLocks_taken...
         + econstructor...
           rewrite lookup_heapUpdate_eq...
           apply heapLookup_lt...
           case_extend.
        }
      * econstructor; simpl...
        introv HIn. inv HIn...
      * econstructor; simpl...
        rewrite H7.
        introv HIn. inv HIn...
    - Case "T_RLock".
      inv_step; try(malformed_context)...
      inv H5.
      econstructor...
      * eapply wfHeldLocks_heapUpdate...
        introv HRL.
        case_extend.
        eapply wfHeldLocks_taken in HRL...
        congruence.
        eapply wfHeldLocks_taken...
      * econstructor; simpl...
        rewrite H7; simpl.
        introv HIn. inv HIn; try(contradiction).
        inv_eq. rewrite lookup_heapUpdate_eq. 
        repeat eexists... 
        cases_if; simpl; try omega.
        apply heapLookup_lt...
    - Case "T_WLocked".
      inv Hfresh.
      inverts H1. 
      assert (wfWl': wfWLocks Ls e) by eauto using wfWLocks_econtext.
      assert (wfRl': wfRLocks H (T_Thread Ls e)) by eauto using wfWLocks_econtext.
      inv_step; try(malformed_context)...
      * inv_eq. 
        assert(Hno_locks: no_locks e1 /\ no_locks e2)
          by eauto using spawn_no_locks.
        assert(wlocks (EWlocked (l, r) e) = wlocks (EWlocked (l, r) e3))
          by (eapply spawn_locks; eauto).
        inverts Hno_locks as no_locks1 no_locks2.
        apply IHhasType2 in Hstep...
        inv Hstep.
        assert(wlocks (EWlocked (l, r) e) = wlocks (EWlocked (l, r) e3)) 
          by eauto using spawn_locks.
        {econstructor...
         + simpls. econstructor...
           - introv HIn. inv HIn...
             inv H1...
             inv H8...
           - simpl. inv_eq. 
         + introv HIn. simpls.
           inv HIn...
           inv no_locks1... rewrite H3...
         + inv H10...
        }
      * inv_eq. 
        assert(HIn': In (l, r) Ls')
          by (eapply noLostLocks in Hstep; try(econstructor); eauto).
        assert(HnIn': ~In (l, r) (wlocks e')).
          inv wfWl. assert (In (l, r) Ls)...
          inv wfLs. rewrite Forall_forall in H8.
          apply H8 in H5. inv H5...
          eapply noDuplicatedLocks in Hstep...
          econstructor...
          econstructor...
          econstructor...
          rewrite Forall_forall...
        apply IHhasType2 in Hstep...
        inv Hstep.
        inv H9.
        inv H10.
        econstructor; simpls...
        econstructor; simpls...
        introv HIn.
        inv HIn...
        inv_eq. 
      * clear IHhasType1. clear IHhasType2.
        {econstructor.
         + econstructor.
           rewrite Forall_forall.
           introv HIn.
           destruct x.
           destruct (id_eq_dec l l0).
           - subst. econstructor...
             rewrite lookup_heapUpdate_eq...
             apply heapLookup_lt...
             case_extend.
             * apply remove_in_eq in HIn. contradiction. 
             * assert(wfLs': wfHeldLocks H (remove id_eq_dec (l0, r) Ls)) 
                 by eauto using wfHeldLocks_remove. 
               eapply wfHeldLocks_taken in HIn... 
           - assert(wfLs': wfHeldLocks H (remove id_eq_dec (l, r) Ls)) 
               by eauto using wfHeldLocks_remove.
             inverts wfLs' as wfLs'.
             rewrite Forall_forall in wfLs'.
             apply wfLs' in HIn.
             inv HIn.
             econstructor... 
             rewrite lookup_heapUpdate_neq...
         + apply remove_NoDup...
         + econstructor; simpls...
           introv contra. inv contra.
         + econstructor; simpls...
           introv contra. inv contra.
        }
    - Case "T_RLocked".
      inv Hfresh.
      assert (wfRLocks H (T_Thread Ls e))
        by (apply wfRLocks_econtext in wfRl; eauto).
      assert (NoDup (wlocks e))
        by (inv H1; eauto).
      inv_step; try(malformed_context); unfold_ctx...
      * inv_eq.
        assert(Hno_locks: no_locks e1 /\ no_locks e2)
          by eauto using spawn_no_locks.
        assert(Hwl: wlocks (ERlocked (l, r) e) = wlocks (ERlocked (l, r) e3))
          by (eapply spawn_locks; eauto).
        assert(Hrl: rlocks (ERlocked (l, r) e) = rlocks (ERlocked (l, r) e3))
          by (eapply spawn_locks; eauto).
        inverts Hno_locks as no_locks1 no_locks2.
        {apply IHhasType2 in Hstep...
         + inv Hstep.
           inv_eq.
           econstructor...
           - econstructor; simpls;
             rewrite <- Hwl...
           - econstructor; simpls.
             inv no_locks1. inv no_locks2.
             rewrite H7. rewrite H15; simpls.
             rewrite <- H6...
         + introv HIn.
           assert (HIn': (l, r) = (l0, r0) \/ In (l0, r0) (rlocks e))
             by eauto using in_app_or.
           apply H2 in HIn' as (c' & F' & RL' & n'' & Hlookup & HRL & Hle)...
           repeat eexists...
           cases_if; simpls; omega.
        }
      * inv_eq. 
        {assert(Hstep': P / (H, V, n, T_Thread Ls (ERlocked (l, r) e)) ==> (H', V', n', T_Thread Ls' (ERlocked (l, r) e')))...
         apply IHhasType2 in Hstep...
         + inv Hstep.
           econstructor...
           - econstructor; simpls;
             inv H10...
           - econstructor. 
             introv HIn. simpls.
             eapply wfRLocks_async_preservation with (l := l0) (r := r0) (RLs := nil) in Hstep'...
             rewrite app_nil_r in Hstep'. simpls. apply Hstep'.
             econstructor... repeat rewrite app_nil_r.
             inv wfRl... rewrite app_nil_r.
             simpls...
         + introv HIn.
           assert (HIn': (l, r) = (l0, r0) \/ In (l0, r0) (rlocks e))
             by eauto using in_app_or.
           apply H2 in HIn' as (c' & F' & RL' & n'' & Hlookup & HRL & Hle)...
           repeat eexists...
           cases_if; simpls; omega.
        }
      * clear IHhasType1. clear IHhasType2.
        {econstructor...
         + eapply wfHeldLocks_heapUpdate...
           introv HIn.
           inverts wfLs as wfLs.
           rewrite Forall_forall in wfLs.
           apply wfLs in HIn...
           inv HIn... rewrite_and_invert.
           case_extend.
         + econstructor; simpls.
           introv contra. inv contra.
        }
  + inverts wfCfg as Hlt wfH wfV wfT wfL.
    inverts wfT as Hfree Hfresh hasType wfT1 wfT2.
    inverts wfL as wfWl HWdisj wfRl Hdisj wfL1 wfL2.
    inv_step...
    - assert (Hdisj': disjointLocks T1' T2)
       by (eapply stepCannotSteal in Hstep; eauto).
      assert (wfLocking H' T2).
        eapply wfLocking_async_preservation with (T1 := T1)...
        inv wfRl; simpls. introv HIn.
        assert(HIn': In (l, r) (t_rlocks T1 ++ t_rlocks T2 ++ rlocks e)).
          apply in_app_or in HIn. inv HIn; eauto using in_or_app.
        apply H0 in HIn' as (c' & F' & RL' & n'' & Hlookup & HRL & Hle)...
        repeat eexists... 
        rewrite filter_app in Hle.
        rewrite filter_app in Hle.
        rewrite filter_app.
        rewrite app_length in Hle. 
        rewrite app_length in Hle. 
        rewrite app_length. omega.
      assert(wfCfg1: wfConfiguration P Gamma (H, V, n, T1) t1)...
      pose proof (IHT1 _ _ _ _ Hstep t1 wfCfg1) as IH.
      inv wfWl.
      econstructor... 
      * econstructor... 
        introv HIn. eapply noLostLocks... 
      * introv HIn. destruct L.
        assert (~In (l, r) (t_wlocks T1))...
        apply H1 in HIn. assert (wfLs: wfHeldLocks H (leftmost_locks T1)) by eauto using wfHeldLocks_leftmost. 
        inverts wfLs as wfLs. rewrite Forall_forall in wfLs. apply wfLs in HIn.
        inv HIn.
        eapply noDuplicatedLocks... 
      * econstructor. introv HIn. simpls.
        {eapply wfRLocks_async_preservation 
         with (l := l) (r := r) (RLs := t_rlocks T2 ++ rlocks e) 
            in Hstep as (c' & F' & RL' & n'' & Hlookup & HRL & Hle)...
         + repeat eexists...
         + introv HIn'.
           inv wfRl; simpls... 
        }
    - assert (Hdisj': disjointLocks T1 T2')
        by (eapply stepCannotSteal in Hstep;
            eauto using disjointLocks_commutative).
      assert (wfLocking H' T1).
        eapply wfLocking_async_preservation with (T1 := T2)...
        apply disjointLocks_commutative...
        inv wfRl; simpls. introv HIn.
        assert(HIn': In (l, r) (t_rlocks T1 ++ t_rlocks T2 ++ rlocks e)).
          apply in_app_or in HIn. inv HIn; eauto using in_or_app.
        apply H0 in HIn' as (c' & F' & RL' & n'' & Hlookup & HRL & Hle)...
        repeat eexists... 
        rewrite filter_app in Hle.
        rewrite filter_app in Hle.
        rewrite app_length in Hle. 
        rewrite app_length in Hle. 
        rewrite filter_app.
        rewrite app_length. omega.
      assert(wfCfg2: wfConfiguration P Gamma (H, V, n, T2) t2)...
      pose proof (IHT2 _ _ _ _ Hstep t2 wfCfg2) as IH.
      inv wfWl.
      econstructor...
      apply wfRLocks_async_commutative.
      econstructor. introv HIn. simpls.
      eapply wfRLocks_async_preservation 
      with (l := l) (r := r) (RLs := t_rlocks T1 ++ rlocks e)
        in Hstep as (c' & F' & RL' & n'' & Hlookup & HRL & Hle)...
      * repeat eexists...
      * introv HIn'.
        inv wfRl; simpls... 
        replaces (length (filter (lock_eq (l, r)) (t_rlocks T2 ++ t_rlocks T1 ++ rlocks e)))
        with (length (filter (lock_eq (l, r)) (t_rlocks T1 ++ t_rlocks T2 ++ rlocks e)));
          try(solve[repeat rewrite filter_app;
                     repeat rewrite app_length; omega]).
        eapply H3... 
        rewrite app_assoc. apply in_comm. rewrite app_assoc.
        apply in_or_app. apply in_app_or in HIn'. 
        inverts HIn' as HIn'... left.
        apply in_comm... 
    - inv wfL1... econstructor... 
      inv wfRl...
      econstructor; simpls...
      introv HIn.
      assert (HIn': In (l, r) (rlocks e1 ++ t_rlocks T2 ++ rlocks e)) by eauto using in_or_app.
      apply H in HIn' as (c' & F' & RL' & n'' & Hlookup & HRL & Hle).
      repeat eexists...
      rewrite filter_app in Hle.
      rewrite filter_app in Hle.
      rewrite app_length in Hle.
      rewrite app_length in Hle.
      omega.
    - econstructor...
      eapply wfHeldLocks_leftmost...
    - econstructor...
      eapply wfHeldLocks_leftmost... 
Grab Existential Variables.
apply (l, r).
Qed.


